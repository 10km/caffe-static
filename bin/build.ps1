<#
自动编译caffe-ssd及其依赖的所有库，
如果指定项目的源码不存在,则自动调用fetch.ps1 下载源码
author: guyadong@gdface.net
#>
param(
[string[]]$names,
[ValidateSet('auto','vs2015','vs2013','gcc')]
[string]$compiler='auto',
[ValidateSet('auto','x86','x86_64')]
[string]$arch='auto',
[ValidateSet('nmake','jom','sln')]
[string]$msvc_project='jom',
[string]$gcc=$DEFAULT_GCC,
[switch]$revert,
[alias('md')]
[switch]$msvc_shared_runtime,
[switch]$debug,
[switch]$build_reserved,
[switch]$help
)

# 用命令行输入的参数初始化 $BUILD_INFO 变量 [PSObject]
$BUILD_INFO=New-Object PSObject -Property @{
    # 编译器类型 vs2013|vs2015|gcc
    compiler=$compiler
    # cpu体系 x86|x86_64
    arch=$arch
    # vs2015 环境变量
    env_vs2015='VS140COMNTOOLS'
    # vs2013 环境变量
    env_vs2013='VS120COMNTOOLS'
    # msvc安装路径 如:"C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC"
    msvc_root=""
    # Visual Studio 版本号 (2013/2015...)
    vs_version=""
    vc_version=@{ 'vs2013'='vc120' 
                  'vs2015'='vc140'}
    msvc_project=$msvc_project
    # MSVC 连接选项使用 /MD
    msvc_shared_runtime=$msvc_shared_runtime
    # gcc安装路径 如:P:\MinGW\mingw64\bin
    gcc_location=$gcc
    # gcc版本号
    gcc_version=""
    # gcc 编译器全路径 如 P:\MinGW\mingw64\bin\gcc.exe
    gcc_c_compiler=""
    # g++ 编译器全路径 如 P:\MinGW\mingw64\bin\g++.exe
    gcc_cxx_compiler=""
    # cmake 参数定义
    cmake_vars_define=""
    # c编译器通用选项 (CMAKE_C_FLAGS)  参见 https://cmake.org/cmake/help/v3.8/variable/CMAKE_LANG_FLAGS.html
    c_flags=""
    # c++编译器通用选项 (CMAKE_CXX_FLAGS),同上
    cxx_flags=""
    # 可执行程序(exe)连接选项(CMAKE_EXE_LINKER_FLAGS) 参见 https://cmake.org/cmake/help/v3.8/variable/CMAKE_EXE_LINKER_FLAGS.html
    exe_linker_flags=""
    # make 工具文件名,msvc为nmake,mingw为make 
    make_exe=""
    nmake_parallel=$jom
    # make 工具编译时的默认选项
    make_exe_option=""
    # install 任务名称,使用msbuild编译msvc工程时名称为'install.vcxproj'
    make_install_target='install'
    # 项目编译成功后是否清除 build文件夹
    build_type=$(if($debug){'debug'}else{'release'})
    remove_build= ! $build_reserved
    # 环境变量快照,由成员 save_env_snapshoot 保存
    # 为保证每个 build_xxxx 函数执行时，环境变量互不干扰，
    # 在开始编译前调用 restore_env_snapshoot 将此变量中保存的所有环境变量恢复到 save_env_snapshoot 调用时的状态
    env_snapshoot=$null
}
# $BUILD_INFO 成员方法 
# 生成调用 cmake 时的默认命令行参数
Add-Member -InputObject $BUILD_INFO -MemberType ScriptMethod -Name make_cmake_vars_define -Value {
    param([string]$c_flags,[string]$cxx_flags,[string]$exe_linker_flags)
    $vars=$this.cmake_vars_define
    if($this.c_flags -or $c_flags){
        $vars+=" -DCMAKE_C_FLAGS=""$($this.c_flags) $c_flags """
    }
    if($this.cxx_flags -or $cxx_flags){
        $vars+=" -DCMAKE_CXX_FLAGS=""$($this.cxx_flags) $cxx_flags """
    }
    if($this.exe_linker_flags -or $exe_linker_flags){
        $vars+=" -DCMAKE_EXE_LINKER_FLAGS=""$($this.exe_linker_flags) $exe_linker_flags """
    }
    $vars
}
# $BUILD_INFO 成员方法 
# 判断编译器是不是 msvc
Add-Member -InputObject $BUILD_INFO -MemberType ScriptMethod -Name is_msvc -Value {
    $this.compiler -match 'vs\d+'
}
# $BUILD_INFO 成员方法 
# 判断编译器是不是 msvc
Add-Member -InputObject $BUILD_INFO -MemberType ScriptMethod -Name is_gcc -Value {
    $this.compiler -eq 'gcc'
}
# $BUILD_INFO 成员方法 
# 进入项目文件夹，如果没有指定 $no_build 清空 build 文件夹,并进入 build文件夹
# 调用者必须将 项目配置对象(如 BOOST_INFO)保存在 $project 变量中
# $no_build 不创建 build 文件夹
Add-Member -InputObject $BUILD_INFO -MemberType ScriptMethod -Name begin_build -Value {
    param([string[]]$sub_folders,[switch]$no_build)
    args_not_null_empty_undefined project
    Write-Host "(开始编译)building $($project.prefix) $($project.version)" -ForegroundColor Yellow
    [string[]]$paths=$SOURCE_ROOT,$project.folder
    $paths+=$sub_folders
    pushd ([io.path]::Combine($paths))
    if(! $no_build){
        $build="build.$($this.compiler)"
        clean_folder $build
        pushd "$build"
    }
    $BUILD_INFO.restore_env_snapshoot()
}
# $BUILD_INFO 成员方法 
# 退出项目文件夹，清空 build 文件夹,必须与 prepare_build 配对使用
Add-Member -InputObject $BUILD_INFO -MemberType ScriptMethod -Name end_build -Value {
    $build="build.$($this.compiler)"
    if( (pwd).path.endsWith($build)){
        popd
        if($this.remove_build){
            remove_if_exist $build
        }        
    }
    popd
}
# $BUILD_INFO 成员方法 
# 保存所有当前环境变量到 env_snapshoot
# 该函数只能被调用一次
Add-Member -InputObject $BUILD_INFO -MemberType ScriptMethod -Name save_env_snapshoot -Value {
    if($this.env_snapshoot){
        call_stack
        throw "(本函数只允许被调用一次),the function can only be called once "
    }
    $this.env_snapshoot=cmd /c set
}
# $BUILD_INFO 成员方法 
# 恢复 env_snapshoot 中保存的环境变量
# 该函数只能在调用 save_env_snapshoot 后被调用
Add-Member -InputObject $BUILD_INFO -MemberType ScriptMethod -Name restore_env_snapshoot -Value {
    if(!$this.env_snapshoot){
        call_stack
        throw "(该函数只能在调用 save_env_snapshoot 后被调用),the function must be called after 'save_env_snapshoot' called  "
    }
    $this.env_snapshoot|
    foreach {
        if ($_ -match "=") {
        $v = $_.split("=")
        Set-Item -Force -Path "env:$($v[0])"  -Value "$($v[1])"
        }
    }
}
# include 公共全局变量    
. "$PSScriptRoot/build_vars.ps1"

# 调用 where 在搜索路径中查找 $who 指定的可执行文件,
# 如果找到则返回第一个结果
# 如果没找到返回空 
function where_first($who){
    args_not_null_empty_undefined who    
    (get-command $who  -ErrorAction SilentlyContinue| Select-Object Definition -First 1).Definition
}

# 测试 gcc 编译器($gcc_compiler)是否能生成$arch指定的代码(32/64位)
# 如果不能，则报错退出
function test_gcc_compiler_capacity([string]$gcc_compiler,[ValidateSet('x86','x86_64')][string]$arch){
    args_not_null_empty_undefined arch gcc_compiler
    # 检查是否为 gcc 编译器
    cmd /c "$gcc_compiler -dumpversion >nul 2>nul"
    exit_on_error "$gcc_compiler is not gcc compiler"
    if($arch -eq 'x86'){
        $c_flags='-m32'
    }elseif($arch -eq 'x86_64'){
        $c_flags='-m64'
    }
    $test=Join-Path $env:TEMP -ChildPath 'test-m32-m64-enable'
    # 在系统 temp 文件夹下生成一个临时 .c 文件
    echo "int main(){return 0;}`n" |Out-File "$test.c" -Encoding ascii -Force
    # 调用指定的编译器在命令行编译 .c 文件
    cmd /c "$gcc_compiler $test.c $c_flags -o $test >nul 2>nul"    
    exit_on_error "指定的编译器不能生成 $arch 代码($gcc_compiler can't build $arch code)"
    # 清除临时文件
    del "$test*" -Force
}
# 根据提供的编译器类型列表，按顺序在系统中侦测安装的编译器，
# 如果找到就返回找到的编译类型名,
# 如果没有找到任何一种编译器则报错退出
function detect_compiler(){  
    foreach ( $arg in $args){
        switch -Regex ($arg){
        '^(vs2015|vs2013)$'{ 
            $vscomntools_name=$BUILD_INFO."env_$arg"
            args_not_null_empty_undefined vscomntools_name
            $vscomntools_value=(ls env:$vscomntools_name -ErrorAction SilentlyContinue).value
            $vc_root=(Get-Item $([io.path]::Combine($vscomntools_value,'..','..','VC')) -ErrorAction SilentlyContinue).FullName
            $cl_exe="$([io.path]::Combine($vc_root,'bin','cl.exe'))"            
            if($vscomntools_value -and (Test-Path "$([io.path]::Combine($vc_root,'bin','cl.exe'))" -PathType Leaf)){
                $BUILD_INFO.msvc_root=$vc_root
                switch($BUILD_INFO.msvc_project){
                'nmake'{
                    $generator='NMake Makefiles'
                    $BUILD_INFO.make_exe='nmake'
                }
                'jom'{
                    exit_if_not_exist $JOM_INFO.root -type Container -msg '(没有安装 jom),not found jom,please install it by running ./fetch.ps1 jom'
                    $generator='NMake Makefiles JOM'
                    $BUILD_INFO.make_exe='jom'
                    args_not_null_empty_undefined MAKE_JOBS
                    $BUILD_INFO.make_exe_option="-j $MAKE_JOBS"
                }
                'sln'{
                    $gp_map=@{
                        vs2013='Visual Studio 12 2013'
                        vs2015='Visual Studio 14 2015'
                        vs2017='Visual Studio 15 2017'
                    }
                    $gs_map=@{
                        x86=''
                        x86_64=' Win64'
                        arm=' ARM'
                    }
                    $generator='{0}{1}' -f $gp_map.$arg,$gs_map.$($BUILD_INFO.arch)
                    $BUILD_INFO.make_exe='msbuild'
                    $BUILD_INFO.make_exe_option="/maxcpucount /t:build /p:Configuration=$($BUILD_INFO.build_type)"
                    $BUILD_INFO.make_install_target='INSTALL.vcxproj'
                }
                default{ call_stack; throw "(无效工程类型)invalid project type:$($BUILD_INFO.msvc_project)"}
                }
                if(! $BUILD_INFO.msvc_shared_runtime){
                    $cmake_user_make_rules_override="-DCMAKE_USER_MAKE_RULES_OVERRIDE=`"$(Join-Path $BIN_ROOT -ChildPath compiler_flag_overrides.cmake)`""   
                }
                                
                $BUILD_INFO.cmake_vars_define="-G `"$generator`" -DCMAKE_BUILD_TYPE:STRING=$($BUILD_INFO.build_type) $cmake_user_make_rules_override"   
                $null = $arg -match 'vs(\d+)'
                $BUILD_INFO.vs_version=$Matches[1] 
                  
                return $arg
            }
        }
        '^gcc$'{ 
            $gcc_exe='gcc.exe'
            if($BUILD_INFO.gcc_location){
                $gcc_exe=Join-Path $BUILD_INFO.gcc_location -ChildPath $gcc_exe
            }else{
                $gcc_exe=where_first $gcc_exe
                if(!$gcc_exe){
                    # 如果系统中没有检测到 gcc 编译器则使用自带的 mingw 编译器
                    $mingw=$(if($BUILD_INFO.arch -eq 'x86'){$MINGW32_INFO}else{$MINGW64_INFO})                    
                    if(!(Test-Path $mingw.root -PathType Container)){
                        continue
                    }
                    $gcc_exe=Join-Path $mingw.root -ChildPath $gcc_exe
                }
            }  
            if(Test-Path $gcc_exe -PathType Leaf){
                $BUILD_INFO.gcc_version=cmd /c "$gcc_exe -dumpversion 2>&1" 
                exit_on_error 
                $BUILD_INFO.gcc_location= (Get-Item $gcc_exe).Directory
                $BUILD_INFO.gcc_c_compiler=$gcc_exe
                $BUILD_INFO.gcc_cxx_compiler=Join-Path $BUILD_INFO.gcc_location -ChildPath 'g++.exe'
                exit_if_not_exist $BUILD_INFO.gcc_cxx_compiler -type Leaf -msg "(没找到g++编译器)not found g++ in $BUILD_INFO.gcc_location"
                $BUILD_INFO.cmake_vars_define="-G ""MinGW Makefiles"" -DCMAKE_C_COMPILER:FILEPATH=""$($BUILD_INFO.gcc_c_compiler)"" -DCMAKE_CXX_COMPILER:FILEPATH=""$($BUILD_INFO.gcc_cxx_compiler)"" -DCMAKE_BUILD_TYPE:STRING=$($BUILD_INFO.build_type)"
                $BUILD_INFO.exe_linker_flags='-static -static-libstdc++ -static-libgcc'
                # 寻找 mingw32 中的 make.exe，一般名为 mingw32-make
                $find=(ls $BUILD_INFO.gcc_location -Filter *make.exe|Select-Object -Property BaseName|Select-Object -First 1 ).BaseName
                if(!$find){
                    throw "这是什么鬼?没有找到make工具啊(not found make tools)"
                }else{
                    $BUILD_INFO.make_exe=$find
                    Write-Host "make tools:" $BUILD_INFO.make_exe -ForegroundColor Yellow
                }                
                args_not_null_empty_undefined MAKE_JOBS
                $BUILD_INFO.make_exe_option="-j $MAKE_JOBS"
                if(!((Get-Item $gcc_exe).FullName -eq "$(where_first gcc)")){
                    # $BUILD_INFO.gcc_location 加入搜索路径
                    $env:path="$($BUILD_INFO.gcc_location);$env:path"
                }
                return $arg
            }            
        }
        Default { Write-Host "invalid compiler type:$arg" -ForegroundColor Red;call_stack;exit -1}
        }
    }
    Write-Host "(没有找到指定的任何一种编译器，你确定安装了么?)not found compiler:$args" -ForegroundColor Yellow
    exit -1
}
# 针对当前编译器 忽略 $BUILD_INFO  中指定名称属性(置为 $null ),并输出提示信息
# 该函数只能在编译已经确定之后调用
function ignore_arguments_by_compiler(){
    echo $args | foreach{
        if($_ -is [array]){
            if($_.count -ne 2){
                call_stack
                throw "(数组型参数长度必须为2),the argument with [arrray] type must have 2 elements"
            }
            $property=$_[0]
            $param=$_[1]
        }else{
            $property=$param=$_
        }        
        if((Get-Member -inputobject $BUILD_INFO -name $property )  -eq $null){            
            call_stack
            throw  "(未定义属性)undefined property '$property'"
        }                
        if($BUILD_INFO.$property){
            Write-Host "(忽略参数)ignore the argument '-$param' while $($BUILD_INFO.compiler) compiler"
            $BUILD_INFO.$property=$null
        }
    }
}
# 初始化 $BUILD_INFO 编译参数配置对象
function init_build_info(){
    Write-Host "初始化编译参数..."  -ForegroundColor Yellow
    # $BUILD_INFO.arch 为 auto时，设置为系统检查到的值
    if($BUILD_INFO.arch -eq 'auto'){
        args_not_null_empty_undefined HOST_PROCESSOR
        $BUILD_INFO.arch=$HOST_PROCESSOR
    }
    if($BUILD_INFO.gcc_location ){        
        $BUILD_INFO.compiler='gcc'
        Write-Host "(重置参数)force set option '-compiler' to 'gcc' while use '-gcc' option" -ForegroundColor Yellow
    }
    if($BUILD_INFO.compiler -eq 'auto'){
        $BUILD_INFO.compiler=detect_compiler  vs2013 vs2015 gcc
    }else{
        $BUILD_INFO.compiler=detect_compiler  $BUILD_INFO.compiler
    }

    if($BUILD_INFO.is_gcc()){
        if($BUILD_INFO.arch -eq 'x86'){
            $BUILD_INFO.c_flags=$BUILD_INFO.cxx_flags='-m32'
        }elseif($BUILD_INFO.arch -eq 'x86_64'){
            $BUILD_INFO.c_flags=$BUILD_INFO.cxx_flags='-m64'
        }
        test_gcc_compiler_capacity -gcc_compiler $BUILD_INFO.gcc_c_compiler -arch $BUILD_INFO.arch
        ignore_arguments_by_compiler msvc_shared_runtime msvc_project
    }    
    make_msvc_env
    $BUILD_INFO.save_env_snapshoot()
}
# 调用 vcvarsall.bat 创建msvc编译环境
# 当编译器选择 gcc 不会执行该函数
# 通过 $env:MSVC_ENV_MAKED 变量保证 该函数只会被调用一次
function make_msvc_env(){
    args_not_null_empty_undefined BUILD_INFO
    if( $BUILD_INFO.is_msvc()){
        if($BUILD_INFO.msvc_project -eq 'jom'){
            #  将jom加入搜索路径
            if( "$(where_first jom)" -ne (Get-Command $JOM_INFO.exe ).Definition){
                $env:Path="$($JOM_INFO.root);$env:Path"
            }
        }
    }
    if( $env:MSVC_ENV_MAKED -ne $BUILD_INFO.arch -and $BUILD_INFO.is_msvc()){
        if($BUILD_INFO.msvc_project -eq 'jom'){
            #  将jom加入搜索路径
            if( "$(where_first jom)" -ne (Get-Command $JOM_INFO.exe ).Definition){
                $env:Path="$($JOM_INFO.root);$env:Path"
            }
        }
        $cmd="""$(Join-Path $($BUILD_INFO.msvc_root) -ChildPath vcvarsall.bat)"""
        if($BUILD_INFO.arch -eq 'x86'){
            $cmd+=' x86'
        }else{
            $cmd+=' x86_amd64'
        }        
        cmd /c "$cmd &set" |
        foreach {
          if ($_ -match "=") {
            $v = $_.split("=")
            Set-Item -Force -Path "env:$($v[0])"  -Value "$($v[1])"
          }
        }
        $env:MSVC_ENV_MAKED=$BUILD_INFO.arch
        write-host "Visual Studio $($BUILD_INFO.vs_version) Command Prompt variables ($env:MSVC_ENV_MAKED) set." -ForegroundColor Yellow
    }
}

# 将分行的命令字符串去掉分行符组合成一行
# 分行符 可以为 '^' '\' 结尾
# 删除 #开头的注释行
function combine_multi_line([string]$cmd){
    args_not_null_empty_undefined cmd    
    ($cmd -replace '\s*#.*\n',''  ) -replace '\s*[\^\\]?\s*\r\n\s*',' ' 
}
# 静态编译 gflags 源码
function build_gflags(){
    $project=$GFLAGS_INFO
    $BUILD_INFO.begin_build()
    $cmd=combine_multi_line "$($CMAKE_INFO.exe) .. $($BUILD_INFO.make_cmake_vars_define()) -DCMAKE_INSTALL_PREFIX=""$($project.install_path())"" 
        -DBUILD_SHARED_LIBS=off         
	    -DBUILD_STATIC_LIBS=on 
	    -DBUILD_gflags_LIB=on 
        -DREGISTER_INSTALL_PREFIX=off 2>&1" 
    cmd /c $cmd
    exit_on_error
    remove_if_exist "$project.install_path()"
    cmd /c "$($BUILD_INFO.make_exe) $($BUILD_INFO.make_exe_option) $($BUILD_INFO.make_install_target) 2>&1"
    exit_on_error
    $BUILD_INFO.end_build()
}
# 静态编译 glog 源码
function build_glog(){
    $project=$GLOG_INFO
    $gflags_DIR=[io.path]::combine($($GFLAGS_INFO.install_path()),'cmake')
    exit_if_not_exist "$gflags_DIR"  -type Container -msg "not found $gflags_DIR,please build $($GFLAGS_INFO.prefix)"
    $BUILD_INFO.begin_build()
    if($BUILD_INFO.is_msvc()){
        # MSVC 关闭编译警告
        $env:CXXFLAGS='/wd4290 /wd4267 /wd4722'
        $env:CFLAGS  ='/wd4290 /wd4267 /wd4722'
    }
    $cmd=combine_multi_line "$($CMAKE_INFO.exe) .. $($BUILD_INFO.make_cmake_vars_define()) -DCMAKE_INSTALL_PREFIX=$($project.install_path()) 
        -Dgflags_DIR=$gflags_DIR 
	    -DBUILD_SHARED_LIBS=off 2>&1"
    cmd /c $cmd
    exit_on_error
    $env:CXXFLAGS=''
    $env:CFLAGS  =''
    remove_if_exist "$project.install_path()"
    cmd /c "$($BUILD_INFO.make_exe) $($BUILD_INFO.make_exe_option) $($BUILD_INFO.make_install_target) 2>&1"
    exit_on_error
    $BUILD_INFO.end_build()
}
# cmake静态编译 bzip2 1.0.5源码
function build_bzip2(){
    $project=$BZIP2_INFO
    $install_path=$project.install_path()
    $BUILD_INFO.begin_build()
    if($BUILD_INFO.is_msvc()){
        # MSVC 关闭编译警告
        $env:CXXFLAGS='/wd4996 /wd4267 /wd4244'
        $env:CFLAGS  ='/wd4996 /wd4267 /wd4244'
    }
    $cmd=combine_multi_line "$($CMAKE_INFO.exe) .. $($BUILD_INFO.make_cmake_vars_define()) -DCMAKE_INSTALL_PREFIX=""$install_path""
        -DCMAKE_POLICY_DEFAULT_CMP0026=OLD
        -DBUILD_SHARED_LIBS=off 2>&1" 
    cmd /c $cmd
    exit_on_error
    $env:CXXFLAGS=''
    $env:CFLAGS  =''
    remove_if_exist "$install_path"
    cmd /c "$($BUILD_INFO.make_exe) $($BUILD_INFO.make_exe_option) $($BUILD_INFO.make_install_target) 2>&1"
    exit_on_error
    $BUILD_INFO.end_build()
}
# 静态编译 boost 源码
function build_boost(){
    $project=$BOOST_INFO
    $install_path=$project.install_path()
    $BUILD_INFO.begin_build($null,$true)

    #exit_if_not_exist $BZIP2_INSTALL_PATH "not found $BZIP2_INSTALL_PATH,please build $BZIP2_PREFIX"
    # 指定依赖库bzip2的位置,编译iostreams库时需要
    #export LIBRARY_PATH=$BZIP2_INSTALL_PATH/lib:$LIBRARY_PATH
    #export CPLUS_INCLUDE_PATH=$BZIP2_INSTALL_PATH/include:$CPLUS_INCLUDE_PATH

    # user-config.jam 位于boost 根目录下
    $jam=Join-Path $(pwd) -ChildPath user-config.jam
    if($BUILD_INFO.is_gcc()){
        # 使用 gcc 编译器时用 user-config.jam 指定编译器路径
        # Out-File 默认生成的文件有bom头，所以生成 user-config.jam 时要指定 ASCII 编码(无bom)，否则会编译时读取文件报错：syntax error at EOF
        $env:BOOST_BUILD_PATH=$pwd
        echo "using gcc : $($BUILD_INFO.gcc_version) : $($BUILD_INFO.gcc_cxx_compiler.Replace('\','/') ) ;" | Out-File "$jam" -Encoding ASCII -Force
        cat "$jam"
        $toolset='toolset=gcc'
    }else{
        $env:BOOST_BUILD_PATH=''
        remove_if_exist "$jam"
        if($BUILD_INFO.compiler -eq 'vs2013'){
            $toolset='toolset=msvc-12.0'
        }elseif($BUILD_INFO.compiler -eq 'vs2015'){
            $toolset='toolset=msvc-14.0'
        }
    }
    if($BUILD_INFO.arch -eq 'x86_64'){
        $address_model='address-model=64'
    }
    
    if($BUILD_INFO.msvc_shared_runtime){
        $runtime_link="runtime-link=shared"
    }else{
        $runtime_link='runtime-link=static'
    }
    
    # 所有库列表
    # atomic chrono container context coroutine date_time exception filesystem 
    # graph graph_parallel iostreams locale log math mpi program_options python 
    # random regex serialization signals system test thread timer wave
    # --without-libraries指定不编译的库
    #./bootstrap.sh --without-libraries=python,mpi,graph,graph_parallel,wave
    # --with-libraries指定编译的库
    Write-Host "runing bootstrap..." -ForegroundColor Yellow
    cmd /c "bootstrap"
    exit_on_error
    Write-Host "bjam clean..." -ForegroundColor Yellow
    cmd /c "bjam --clean 2>&1"
    exit_on_error
    remove_if_exist "$install_path"    

    # --prefix 指定安装位置
    # --debug-configuration 编译时显示加载的配置信息
    # -q 参数指示出错就停止编译
    # link=static 只编译静态库
    # --with-<library> 编译安装指定的库<library>
    # -a 全部重新编译
    # -jx 并发编译线程数
    Write-Host "boost compiling..." -ForegroundColor Yellow
    args_not_null_empty_undefined MAKE_JOBS
    $cmd=combine_multi_line "bjam --prefix=$install_path -a -q -d+3 -j$MAKE_JOBS --debug-configuration   
        --with-date_time
        --with-system
        --with-thread
        --with-filesystem
        --with-regex 
        link=static 
        variant=$($BUILD_INFO.build_type) $runtime_link $toolset $address_model 
        install 2>&1"
    cmd /c $cmd 
    exit_on_error
    $BUILD_INFO.end_build()
}
# 静态编译 protobuf 源码
function build_protobuf(){
    $project=$PROTOBUF_INFO
    $install_path=$project.install_path()
    $BUILD_INFO.begin_build()
    if($BUILD_INFO.msvc_shared_runtime){
        $protobuf_msvc_static_runtime="-Dprotobuf_MSVC_STATIC_RUNTIME=off"
    }
    $cmd=combine_multi_line "$($CMAKE_INFO.exe) ../cmake $($BUILD_INFO.make_cmake_vars_define()) -DCMAKE_INSTALL_PREFIX=""$install_path"" 
    	    -Dprotobuf_BUILD_TESTS=off 
            $protobuf_msvc_static_runtime
			-Dprotobuf_BUILD_SHARED_LIBS=off 2>&1" 
    cmd /c $cmd
    exit_on_error
    remove_if_exist "$install_path"
    cmd /c "$($BUILD_INFO.make_exe) $($BUILD_INFO.make_exe_option) $($BUILD_INFO.make_install_target) 2>&1"
    exit_on_error
    $BUILD_INFO.end_build()
}
# 静态编译 hdf5 源码
function build_hdf5(){
    $project=$HDF5_INFO
    $install_path=$project.install_path()
    $BUILD_INFO.begin_build($project.folder)
    $cmd=combine_multi_line "$($CMAKE_INFO.exe) .. $($BUILD_INFO.make_cmake_vars_define()) -DCMAKE_INSTALL_PREFIX=""$install_path"" 
        -DBUILD_SHARED_LIBS=off 
		-DBUILD_TESTING=off 
		-DHDF5_BUILD_FORTRAN=off 
		-DHDF5_BUILD_EXAMPLES=off 
		-DHDF5_BUILD_TOOLS=off 
		-DHDF5_DISABLE_COMPILER_WARNINGS=on 
		-DSKIP_HDF5_FORTRAN_SHARED=off 2>&1" 
    cmd /c $cmd
    exit_on_error
    remove_if_exist "$install_path"
    cmd /c "$($BUILD_INFO.make_exe) $($BUILD_INFO.make_exe_option) $($BUILD_INFO.make_install_target) 2>&1"
    exit_on_error
    $BUILD_INFO.end_build()
}
# 静态编译 snappy 源码
function build_snappy(){
    $project=$SNAPPY_INFO
    $install_path=$project.install_path()
    $gflags_DIR=[io.path]::combine($($GFLAGS_INFO.install_path()),'cmake')
    exit_if_not_exist "$gflags_DIR"  -type Container -msg "not found $gflags_DIR,please build $($GFLAGS_INFO.prefix)"
    $BUILD_INFO.begin_build()
    if($BUILD_INFO.is_msvc()){
        # MSVC 关闭编译警告
        $env:CXXFLAGS='/wd4819 /wd4267 /wd4244 /wd4018 /wd4005'
        $env:CFLAGS  ='/wd4819 /wd4267 /wd4244 /wd4018 /wd4005'
    }
    $cmd=combine_multi_line "$($CMAKE_INFO.exe) .. $($BUILD_INFO.make_cmake_vars_define()) -DCMAKE_INSTALL_PREFIX=""$install_path"" 
        -DGflags_DIR=$gflags_DIR 
        -DBUILD_SHARED_LIBS=off 2>&1" 
    cmd /c $cmd
    exit_on_error
    $env:CXXFLAGS=''
    $env:CFLAGS  =''
    remove_if_exist "$install_path"
    cmd /c "$($BUILD_INFO.make_exe) $($BUILD_INFO.make_exe_option) $($BUILD_INFO.make_install_target) 2>&1"
    exit_on_error
    $BUILD_INFO.end_build()
}
# 静态编译 opencv 源码
function build_opencv(){
    $project=$OPENCV_INFO
    $install_path=$project.install_path()
    # 如果不编译 FFMPEG 不需要 bzip2
    #bzip2_libraries=$BZIP2_INSTALL_PATH/lib/libbz2.a
    #exit_if_not_exist $bzip2_libraries "not found $bzip2_libraries,please build $BZIP2_PREFIX"
 
    $BUILD_INFO.begin_build()
    if($BUILD_INFO.is_msvc()){
        $build_with_static_crt="-DBUILD_WITH_STATIC_CRT=$(if($BUILD_INFO.msvc_shared_runtime){'off'}else{'on'})"
    }elseif($BUILD_INFO.is_gcc()){
        $build_fat_java_lib='-DBUILD_FAT_JAVA_LIB=off'
    }
    if($BUILD_INFO.is_msvc()){
        # MSVC 关闭编译警告
        $env:CXXFLAGS='/wd4819'
        $env:CFLAGS  ='/wd4819'
    }
    # 如果不编译 FFMPEG , cmake时不需要指定 BZIP2_LIBRARIES
	#	-DBZIP2_LIBRARIES=$BZIP2_INSTALL_PATH/lib/libbz2.a 
    $cmd=combine_multi_line "$($CMAKE_INFO.exe) .. $($BUILD_INFO.make_cmake_vars_define()) -DCMAKE_INSTALL_PREFIX=""$install_path"" 
            $build_with_static_crt
            $build_fat_java_lib
			-DBUILD_DOCS=off 
			-DBUILD_SHARED_LIBS=off 
			-DBUILD_PACKAGE=on 
			-DBUILD_PERF_TESTS=off 
			-DBUILD_FAT_JAVA_LIB=off 
			-DBUILD_TESTS=off 
			-DBUILD_TIFF=on 
			-DBUILD_JASPER=on 
			-DBUILD_JPEG=on 
			-DBUILD_OPENEXR=on 
			-DBUILD_PNG=on 
			-DBUILD_ZLIB=on 
			-DBUILD_opencv_apps=off 
			-DBUILD_opencv_calib3d=off 
			-DBUILD_opencv_contrib=off 
			-DBUILD_opencv_features2d=off 
			-DBUILD_opencv_flann=off 
			-DBUILD_opencv_gpu=off 
			-DBUILD_opencv_java=off 
			-DBUILD_opencv_legacy=off 
			-DBUILD_opencv_ml=off 
			-DBUILD_opencv_nonfree=off 
			-DBUILD_opencv_objdetect=off 
			-DBUILD_opencv_ocl=off 
			-DBUILD_opencv_photo=off 
			-DBUILD_opencv_python=off 
			-DBUILD_opencv_stitching=off 
			-DBUILD_opencv_superres=off 
			-DBUILD_opencv_ts=off 
			-DBUILD_opencv_video=off 
			-DBUILD_opencv_videostab=off 
			-DBUILD_opencv_world=off 
			-DBUILD_opencv_lengcy=off 
            -DWITH_DSHOW=off
			-DWITH_JASPER=on 
			-DWITH_JPEG=on 
			-DWITH_1394=off 
			-DWITH_OPENEXR=on 
			-DWITH_PNG=on 
			-DWITH_TIFF=on 
			-DWITH_1394=off 
			-DWITH_EIGEN=off 
			-DWITH_FFMPEG=off 
			-DWITH_GIGEAPI=off 
			-DWITH_GSTREAMER_0_10=off 
			-DWITH_PVAPI=off 
			-DWITH_CUDA=off 
			-DWITH_CUFFT=off 
			-DWITH_OPENCL=off 
			-DWITH_OPENCLAMDBLAS=off 
			-DWITH_OPENCLAMDFFT=off 
            -DWITH_QT=off
            -DWITH_VFW=off
            -DWITH_VTK=off
            -DWITH_XIMEA=off
            -DWITH_WIN32UI=off 
            2>&1" 
    cmd /c $cmd
    exit_on_error
    $env:CXXFLAGS=''
    $env:CFLAGS  =''
    remove_if_exist "$install_path"
    cmd /c "$($BUILD_INFO.make_exe) $($BUILD_INFO.make_exe_option) $($BUILD_INFO.make_install_target) 2>&1"
    exit_on_error
    $BUILD_INFO.end_build()
}
# cmake静态编译 leveldb(bureau14)源码
function build_leveldb(){
    $project=$LEVELDB_INFO
    $install_path=$project.install_path()
    $boost_root=$BOOST_INFO.install_path()
    exit_if_not_exist "$boost_root"  -type Container -msg "not found $boost_root,please build $($BOOST_INFO.prefix)"
    $BUILD_INFO.begin_build()
    if($BUILD_INFO.is_msvc()){
        # MSVC 关闭编译警告
        $env:CXXFLAGS='/wd4312 /wd4244 /wd4018'
        $env:CFLAGS  ='/wd4312 /wd4244 /wd4018'
    }
    $boost_use_static_runtime=$(if( $BUILD_INFO.msvc_shared_runtime){'off'}else{'on'})
    $cmd=combine_multi_line "$($CMAKE_INFO.exe) .. $($BUILD_INFO.make_cmake_vars_define()) -DCMAKE_INSTALL_PREFIX=""$install_path""
        -DBOOST_ROOT=`"$boost_root`"
	    -DBoost_NO_SYSTEM_PATHS=on 
        -DBoost_USE_STATIC_RUNTIME=$boost_use_static_runtime
        -DBUILD_SHARED_LIBS=off 2>&1" 
    cmd /c $cmd
    exit_on_error
    $env:CXXFLAGS=''
    $env:CFLAGS  =''
    remove_if_exist "$install_path"
    cmd /c "$($BUILD_INFO.make_exe) $($BUILD_INFO.make_exe_option) $($BUILD_INFO.make_install_target) 2>&1"
    exit_on_error
    $BUILD_INFO.end_build()
}
# 静态编译 OpenBLAS 源码,在 MSYS2 中编译，需要 msys2 支持
function build_openblas(){
    $project=$OPENBLAS_INFO
    # 检查是否有安装 msys2 如果没有安装则退出
    if( ! $MSYS2_INSTALL_LOCATION ){
        throw "没有安装MSYS2,不能编译OpenBLAS,MSYS2 not installed,please install,run : ./fetch.ps1 msys2"
    }
    $binary=$(if($BUILD_INFO.arch -eq 'x86'){32}else{64})    
    $mingw_make="mingw32-make"
    if($BUILD_INFO.is_gcc()){
        $mingw_bin=$BUILD_INFO.gcc_location
        $mingw_make=$BUILD_INFO.make_exe
        $mingw_version=$BUILD_INFO.gcc_version
    }elseif($BUILD_INFO.arch -eq 'x86'){
        $mingw_bin= Join-Path $MINGW32_INFO.root -ChildPath 'bin'
        exit_if_not_exist $mingw_bin -type Container -msg "(没有安装 mingw32 编译器),mingw32 not found,install it by running ./fetch.ps1 mingw32"
        $mingw_version=$MINGW32_INFO.version
    }else{
        $mingw_bin= Join-Path $MINGW64_INFO.root -ChildPath 'bin'
        exit_if_not_exist $mingw_bin -type Container -msg "(没有安装 mingw64 编译器),mingw64 not found,install it by running ./fetch.ps1 mingw64"
        $mingw_version=$MINGW64_INFO.version
    }    
    $src_root=Join-Path -Path $SOURCE_ROOT -ChildPath $project.folder
    $msys2bash=[io.path]::Combine($MSYS2_INSTALL_LOCATION,'usr','bin','bash')
    # 不用 msys2_shell.cmd 执行脚本是因为返回的exit code总是0，无法判断脚本是否正确执行
    #$msys2bash=[io.path]::Combine($MSYS2_INSTALL_LOCATION,'msys2_shell.cmd')
    $install_path=unix_path($project.install_path())
    #  USE_FOR_MSVC 宏定义用于控制编译 openblas 静态库代码时不使用 libmsvcrt.a 中的函数
    #　参见 $openblase_source/Makefile.system 中 USE_FOR_MSVC 定义说明    
    $use_for_msvc=$(if($BUILD_INFO.is_msvc()){' export USE_FOR_MSVC=1 ; '}else{''})
    #$debug_build=$(if($BUILD_INFO.build_type -eq 'debug'){'DEBUG=1'}else{''})
    # openblas 编译release版本,不受$BUILD_INFO.build_type控制,
    $debug_build='DEBUG=0'
    args_not_null_empty_undefined MAKE_JOBS
    remove_if_exist "$install_path"
    # MSYS2 下的gcc 编译脚本 (bash)
    # 任何一步出错即退出脚本 exit code = -1
    # 每一行必须 ; 号结尾(最后一行除外)
    # #号开头注释行会被 combine_multi_line 函数删除,不会出现在运行脚本中
    $bashcmd="export PATH=$(unix_path($mingw_bin)):`$PATH ;$use_for_msvc
        # 切换到 OpenBLAS 源码文件夹 
        cd `"$(unix_path $src_root)`" ; 
        # 先执行make clean
        echo start make clean,please waiting...;
        $mingw_make clean ;
        if [ ! `$? ];then exit -1;fi; 
        # BINARY 用于指定编译32位还是64位代码 -j 选项用于指定多线程编译
        $mingw_make -j $MAKE_JOBS BINARY=$binary $debug_build NOFORTRAN=1 NO_LAPACKE=1 NO_SHARED=1 ; 
        if [ ! `$? ];then exit -1;fi;
        # 安装到 $install_path 指定的位置
        $mingw_make install PREFIX=`"$install_path`" NO_LAPACKE=1 NO_SHARED=1"
    $cmd=combine_multi_line "$msys2bash -l -c `"$bashcmd`" 2>&1"
    #$cmd="$msys2bash -where $src_root -l -c `"$bashcmd`" 2>&1"
    Write-Host "(OpenBLAS 编译中...)compiling OpenBLAS by MinGW $mingw_version ($mingw_bin)" -ForegroundColor Yellow
    cmd /c $cmd
    exit_on_error
}
# cmake静态编译 lmdb 源码
function build_lmdb(){
    $project=$LMDB_INFO
    $install_path=$project.install_path()
    $BUILD_INFO.begin_build(@('libraries','liblmdb'))
    $cmd=combine_multi_line "$($CMAKE_INFO.exe) .. $($BUILD_INFO.make_cmake_vars_define()) -DCMAKE_INSTALL_PREFIX=""$install_path""  
        -DCLOSE_WARNING=on
        -DBUILD_TEST=off
        -DBUILD_SHARED_LIBS=off 2>&1" 
    cmd /c $cmd
    exit_on_error
    remove_if_exist "$install_path"
    cmd /c "$($BUILD_INFO.make_exe) $($BUILD_INFO.make_exe_option) $($BUILD_INFO.make_install_target) 2>&1"
    exit_on_error
    $BUILD_INFO.end_build()
}
# 检查指定的组件是否已经编译安装
# 如果缺少，则将错误信息添加到 $error_msg 
function check_component([string]$folder,[PSObject]$info,[ref][string[]]$error_msg){
    args_not_null_empty_undefined folder info error_msg
    $null=(! (exist_file $folder)) -and ( $error_msg.Value+="(缺少 $($info.prefix) ),not found $folder,please build it by running ./build.ps1 $($info.prefix)")
}
# cmake静态编译 caffe 系列源码
function build_caffe([PSObject]$project){
    args_not_null_empty_undefined project
    if($project.prefix -ne 'caffe'){
        throw "not project caffe based $project"
    }
    $install_path=$project.install_path()
    # 调用 check_component 函数依次检查编译 caffe 所需的依赖库是否齐全
    # 保存错误信息的数组,调用check_component时如果有错，错误保存到数组
    [string[]]$error_message=@()
    check_component $GFLAGS_INFO.install_path() $GFLAGS_INFO ([ref]$error_message)
    check_component $GLOG_INFO.install_path() $GLOG_INFO ([ref]$error_message)
    # hdf5 cmake 位置  
    $hdf5_cmake_dir="$($HDF5_INFO.install_path())/cmake"
    check_component $hdf5_cmake_dir $HDF5_INFO ([ref]$error_message)
    check_component $BOOST_INFO.install_path() $BOOST_INFO ([ref]$error_message)
    check_component $OPENBLAS_INFO.install_path() $OPENBLAS_INFO ([ref]$error_message)
    check_component $PROTOBUF_INFO.install_path() $PROTOBUF_INFO ([ref]$error_message)
    # protobuf lib 路径
    $protobuf_lib="$($PROTOBUF_INFO.install_path())/lib"
    check_component $SNAPPY_INFO.install_path() $SNAPPY_INFO ([ref]$error_message)
    check_component $LMDB_INFO.install_path() $LMDB_INFO ([ref]$error_message)
    check_component $LEVELDB_INFO.install_path() $LEVELDB_INFO ([ref]$error_message)
    # opencv 配置文件(OpenCVConfig.cmake)所在路径
    $opencv_cmake_dir="$($OPENCV_INFO.install_path())"
    check_component $opencv_cmake_dir $OPENCV_INFO ([ref]$error_message)
    # 缺少依赖库时报错退出
    if($error_message.count){
        echo $error_message
        exit -1
    }
    $BUILD_INFO.begin_build()
    # 指定 OpenBLAS 安装路径 参见 $caffe_source/cmake/Modules/FindOpenBLAS.cmake
    $env:OpenBLAS_HOME=$OPENBLAS_INFO.install_path()
    # 指定 lmdb 安装路径 参见 $caffe_source/cmake/Modules/FindLMDB.cmake.cmake
    $env:LMDB_DIR=$LMDB_INFO.install_path()
    # 指定 leveldb 安装路径 参见 $caffe_source/cmake/Modules/FindLevelDB.cmake.cmake
    $env:LEVELDB_ROOT=$LEVELDB_INFO.install_path()
    # GLOG_ROOT_DIR 参见 $caffe_source/cmake/Modules/FindGlog.cmake
    # GFLAGS_ROOT_DIR 参见 $caffe_source/cmake/Modules/FindGFlags.cmake
    # HDF5_ROOT 参见 https://cmake.org/cmake/help/v3.8/module/FindHDF5.html
    # BOOST_ROOT,Boost_NO_SYSTEM_PATHS Boost_USE_STATIC_LIBS Boost_USE_STATIC_RUNTIME 参见 https://cmake.org/cmake/help/v3.8/module/FindBoost.html
    # SNAPPY_ROOT_DIR 参见 $caffe_source/cmake/Modules/FindSnappy.cmake
    # COPY_PREREQUISITES=off 关闭 windows 版预编译库下载 参见 $caffe_source/CMakeLists.txt
    # PROTOBUF_LIBRARY,PROTOBUF_PROTOC_LIBRARY... 参见 https://cmake.org/cmake/help/v3.8/module/FindProtobuf.html
    # OpenCV_DIR 参见https://cmake.org/cmake/help/v3.8/command/find_package.html
    $lib_suffix=$(if($BUILD_INFO.is_msvc()){'.lib'}else{'.a'})
    if($BUILD_INFO.is_msvc()){
        # MSVC 关闭编译警告
        $close_warning='/wd4996 /wd4267 /wd4244 /wd4018 /wd4800 /wd4661 /wd4812 /wd4309 /wd4305'
        #if($BUILD_INFO.build_type -eq 'debug'){
        #    $exe_link_opetion='/SAFESEH:NO'
        #}
        
    }
    $boost_use_static_runtime=$(if( $BUILD_INFO.msvc_shared_runtime){'off'}else{'on'})
    # 宏定义 /DGOOGLE_GLOG_DLL_DECL= /DGLOG_NO_ABBREVIATED_SEVERITIES 用于解决 glog 连接报错
    $env:CXXFLAGS="/DGOOGLE_GLOG_DLL_DECL= /DGLOG_NO_ABBREVIATED_SEVERITIES $close_warning"
    $env:CFLAGS  ="/DGOOGLE_GLOG_DLL_DECL= /DGLOG_NO_ABBREVIATED_SEVERITIES $close_warning"
    $cmd=combine_multi_line "$($CMAKE_INFO.exe) .. $($BUILD_INFO.make_cmake_vars_define('','',$exe_link_opetion)) -DCMAKE_INSTALL_PREFIX=""$install_path"" 
        -DCOPY_PREREQUISITES=off
        -DINSTALL_PREREQUISITES=off
	    -DGLOG_ROOT_DIR=`"$($GLOG_INFO.install_path())`"
	    -DGFLAGS_ROOT_DIR=`"$($GFLAGS_INFO.install_path())`" 
	    -DHDF5_ROOT=`"$($HDF5_INFO.install_path())`"
        -DHDF5_USE_STATIC_LIBRARIES=on
	    -DBOOST_ROOT=`"$($BOOST_INFO.install_path())`" 
	    -DBoost_NO_SYSTEM_PATHS=on 
        -DBoost_USE_STATIC_LIBS=on
        -DBoost_USE_STATIC_RUNTIME=$boost_use_static_runtime
	    -DSNAPPY_ROOT_DIR=`"$($SNAPPY_INFO.install_path())`"
	    -DOpenCV_DIR=`"$opencv_cmake_dir`" 
        -DProtobuf_DIR=`"$(Join-Path $PROTOBUF_INFO.install_path() -ChildPath cmake)`"
#	    -DPROTOBUF_LIBRARY=`"$(Join-Path $protobuf_lib -ChildPath "libprotobuf$lib_suffix" )`"
#	    -DPROTOBUF_PROTOC_LIBRARY=`"$(Join-Path $protobuf_lib -ChildPath "libprotoc$lib_suffix")`"
#	    -DPROTOBUF_LITE_LIBRARY=`"$(Join-Path $protobuf_lib -ChildPath "libprotobuf-lite$lib_suffix")`"
#	    -DPROTOBUF_PROTOC_EXECUTABLE=`"$([io.path]::Combine($($PROTOBUF_INFO.install_path()),'bin','protoc.exe'))`"
# PROTOBUF_INCLUDE_DIR 提供的路径分隔符必须是/,否则会引起 cmake 报错
#	    -DPROTOBUF_INCLUDE_DIR=`"$($PROTOBUF_INFO.install_path().replace('\','/'))/include`"
	    -DCPU_ONLY=ON 
	    -DBLAS=Open 
	    -DBUILD_SHARED_LIBS=off 
	    -DBUILD_docs=off 
	    -DBUILD_python=off 
	    -DBUILD_python_layer=off 
	    -DUSE_LEVELDB=on 
	    -DUSE_LMDB=on 
	    -DUSE_OPENCV=on  2>&1" 
    cmd /c $cmd
    exit_on_error
    $env:CXXFLAGS=''
    $env:CFLAGS=''
    # 修改所有 link.txt 删除-lstdc++ 选项，保证静态连接libstdc++库,否则在USE_OPENCV=on的情况下，libstdc++不会静态链接
    if($BUILD_INFO.is_gcc()){
        ls . -Filter link.txt -Recurse|foreach {    
	        echo "modifing file: $_"
	        sed -i -r "s/-lstdc\+\+/ /g" $_
            (Get-Content $_) -replace '(^-lstdc\+\+','' | Out-File $_ -Encoding ascii -Force
        }
    }
    remove_if_exist "$install_path"
    cmd /c "$($BUILD_INFO.make_exe) $($BUILD_INFO.make_exe_option) $($BUILD_INFO.make_install_target) 2>&1"
    exit_on_error
    $BUILD_INFO.end_build()
}
# 输出帮助信息
function print_help(){
    if($(chcp ) -match '\.*936$'){
	    echo "用法: $current_script_name [-names] [项目名称列表,...] [可选项...] 
编译安装指定的项目,如果没有指定项目名称，则编译所有项目
    -n,-names       项目名称列表(逗号分隔,忽略大小写,无空格)
                    可选的项目名称: $($all_project_names -join ',') 
选项:
    -c,-compiler    指定编译器类型,可选值: vs2013,vs2015,gcc,默认 auto(自动侦测)
                    指定为gcc时,如果没有检测到MinGW编译器,则使用本系统自带的MinGW编译器
    -a,-arch        指定目标代码类型(x86,x86_64),默认auto(自动侦测)
    -g,-gcc         指定MingGW编译器的安装路径(bin文件夹),指定此值后，编译器类型(-compiler)自动设置为gcc
    -r,-revert      对项目强制执行fetch,将项目代码恢复到初始状态 
    -msvc_project   指定cmake 生成的MSVC工程类型及编译工具,默认为 JOM,仅在使用MSVC编译时有效
                    nmake: NMake Makefiles ,nmake单线程编译
                    jom  : NMake Makefiles JOM,jom并行编译,CPU满功率运行,比nmake提高数倍的速度
                    sln  : Visual Studio工程(.sln),msbuild并行编译
    -md,-msvc_shared_runtime  
                    MSVC编译时使用 /MD 连接选项,默认 /MT
    -debug          编译Debug版本,默认Release
    -build_reserved 保存编译生成工程文件及中间文件
    -h,-help        显示帮助信息
作者: guyadong@gdface.net
"
    }else{
        echo "usage: $current_script_name [-names] [PROJECT_NAME,...] [options...] 
build & install projects specified by project name,
all projects builded if no name argument
    -n,-names       prject names(split by comma,ignore case,without blank)
                    optional project names: $($all_project_names -join ',')

options:
    -c,-compiler    compiler type,valid value:'vs2013','vs2015','gcc',default 'auto' 
    -a,-arch        target processor architecture: 'x86','x86_64',default 'auto'
    -g,-gcc         MinGW compiler location('bin' folder,such as 'P:\MinGW\mingw64\bin'),
                    the '-compiler' option will be overwrited  to 'gcc' if this option defined 
    -r,-revert      force fetch the project,revert source code
    -j,-jom         jom parallel build with multiple CPU,effective only when MSVC
    -msvc_project   project file type generated by cmake,default JOM,effective only when MSVC
                    nmake: NMake Makefiles ,serial build by nmake 
                    jom  : NMake Makefiles JOM,parallel build by jom 
                    sln  : Visual Studio工程(.sln),parallel build by MSBuild
    -md,-msvc_shared_runtime  
                    use /MD link option,default /MT ,effective only when MSVC
    -debug          Debug building, default is Release
    -build_reserved reserve thd build folder while project building finished
	-h,-help        print the message
author: guyadong@gdface.net
"
    }
}
# 确保 $input 中的字符串不重复且顺序与 $available_names 中的一致,
# 不包含在 $available_names 中的字符串加在最后
function sorted_project([string[]]$available_names){
    args_not_null_empty_undefined available_names
    $pipeline_data = @($Input)
    $unique_input=$pipeline_data |Sort-Object | Get-Unique
    $sorted_names=@()
    $available_names | foreach{
        if($unique_input -contains $_){
            $sorted_names+=$_
        }
    }
    $pipeline_data|foreach{
        if($sorted_names -notcontains $_){
            $sorted_names+=$_
        }
    }
    $sorted_names
}
# 所有项目列表字符串数组
$all_project_names="gflags glog bzip2 boost leveldb lmdb snappy openblas hdf5 opencv protobuf caffe_windows".Trim() -split '\s+'
# 当前脚本名称
$current_script_name=$($(Get-Item $MyInvocation.MyCommand.Definition).Name)
if($help){
    print_help  
    exit 0
}
# 多线程编译参数 make -j 
$MAKE_JOBS=get_logic_core_count
init_build_info
Write-Host 操作系统:$HOST_OS,$HOST_PROCESSOR -ForegroundColor Yellow
Write-Host 编译器配置: -ForegroundColor Yellow
$BUILD_INFO

# 没有指定 names 参数时编译所有项目
if(! $names){
    $names= $all_project_names
}
# 因为各个项目之间有前后依赖关系,所以这里对输入的名字顺序重新排列，确保正确的依赖关系
$names=$names | sorted_project $all_project_names
echo $names| foreach {    
    if( ! (Test-Path function:"build_$($_.ToLower())") -and !($_.StartsWith('caffe'))   ){
        echo "(不识别的项目名称)unknow project name:$_"
        print_help
        exit -1
    }
}
$fetch_names=@()
if($revert){
    $fetch_names=$names
}else{
    echo $names| foreach {
        # 如果源码文件夹不存在,则需要fetch该项目   
        $info=Get-Variable "$($_.ToLower())_INFO" -ValueOnly
        if(  ! (Test-Path (Join-Path $SOURCE_ROOT -ChildPath $info.folder) -PathType Container)){
            $fetch_names+=$_
        }
    }
}
if($fetch_names.Count){
    if($revert){
        &$PSScriptRoot/fetch.ps1 $fetch_names -force
    }else{
        &$PSScriptRoot/fetch.ps1 $fetch_names
    }    
}
# 顺序编译 $names 中指定的项目
echo $names| foreach {
    if($_.StartsWith('caffe')){
        build_caffe(Get-Variable "$($_.ToLower())_INFO" -ValueOnly)
    }else{
        &build_$($_.ToLower())      
    }     
}